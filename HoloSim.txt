This is README file for the HoloSim:

Background:

HoloSim is simulator of the moxel (constrained 1D motion environment) based environment that is controlled using GPU. It is written as the part of the PhD work of Veljko Krunic.

Capabilities demonstrated by HoloSim:

1. Use of the GPU for the calculation of the moxel position.
2. Visualization of the moxel position using GPU.
3. Massively scalable calculation of moxel position
4. Ability to run program on moxel level using fragment shaders
5. Meeting of the performance requirements 
6. Performance statistics presented
7. Ability to decimate large moxel mashes for the purpose of faster visualization and Moir√© effect reduction.
8. Meeting of the performance goals set in PhD
9. Ability to load Collada based models (only subset of Collada functionality supported)

Background for HoloSim setup:

1. HoloSim extensively uses unit testing and test driven development. It is setup in such a way that as a part of every build, set of the tests is run and if those tests fail, build fails.

2. Performance goals are included as a part of the unit test (e.g. as a part of build, program would test that performance goals stated in the PhD were met)

3. Program is written on the OS X in XCode (project files are included). Portability on the iPhone 3GS and later is relatively simple, but not done yet (might be relevant if we are to combine it with the touch based surface later).

4. Open source libraries were used when available for the supporting tasks, but 100% of the code relevant to the demonstration of PhD techniques is written by me and is not using any third party libraries except the ones that are shipped as a part of OS (e.g. OpenGL, math library, GUI library etc). Open source is used to reduce the burden of mandane tasks (e.g. loading Collada models) only. 

5. In some situations (e.g. initialization of the off-screen rendering), I was using Apple's example as a starting point. License for example allows for that type of use, and it is acknowledged in the source files that did it (and would be acknowledged later)

6. Code is documented and automated generation is part of the build process 

7. High level architecture is that we are using MVC (Model View Controller) design pattern.

Directory structure:

1. High level structure:
i) Cocoa holds OS X specific UI code.
ii) Control holds code for the HID (e.g. mouse) control of the viewer. As experience showed that simple control used was working well enough for the user and didn't cause any noticeable artifacts in the day to day use, it was decided not to use quaternion based calculation.
iii) Graphics is holding visualization code for showing moxel position. It is not holding GPU related code.
iv) Doc is holding documentation (this readme file and autogen documentation). If you are interested in documentation on the class level, please open index.html in the AutoGenerated directory
v) IO is Collada loader based on ColladaDOM. Although it is allowing use of the tools like Google Sketchup and Collada format has a lot of interoperability advantages my advice in retrospective is that if you think about using ColladaDOM library - don't. Library is very buggy, very difficult to compile (at least on Mac) and is poorly designed/not saving much compared to direct reading of DOM using Xalan or Xerces.
vi) Math holds various mathematical functions
vii) Model is holding model. GPUInterpolatedModel is responsible for the decimation of the model (so that e.g. 100 moxels might be shown as single one). Note that we always calculate position of every single moxel, then decimate if needed. GPU based calculation happens in GPUCalculationEngine and GPUGeometryModel files. In the GLSL we have shader related code.
viii) ModelFiles is holding files used in the model, as well as SlowInSlowOut.fs that is shader that simulates slow-in, slow-out like effect using piecewise linear interpolation. This shader is used as an example of the simple shader affecting per pixel behavior.
ix) UnitTests holds various unit tests. Of particular interests might be Perf directory and file PerformanceTest.cpp, with the test testStatedPerformance testing that we are reaching stated performance goal from the PhD proposal. Note that not only it is testing that we reaching specified performance based on the clock, but that clock's behavior is what we think it is.
x) UnitTestModels are various models used for the purpose of unit testing
xi) Util are various utilities related to the design by contract and statistics functionality of the program.
