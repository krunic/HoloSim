#import <OpenGL/gl.h>

#import "HoloDeckView.h"

#import "Constants.h"
#import "HoloSimDocument.h"
#import "MouseAdapter.h"
#import "OpenGLDrawingCode.h"

@implementation HoloDeckView

/**
 * Create OpenGL drawing context compliant with the window our needs (double buffered with depth buffer).
 *
 * @return OpenGL context that is compliant with what we need
 */
- (NSOpenGLContext*)getMyContext
{
   // Specify the pixel-format attributes.
   NSOpenGLPixelFormatAttribute attrs[] =
   {
      NSOpenGLPFAWindow,
      NSOpenGLPFADoubleBuffer,
      NSOpenGLPFAAccelerated,
      NSOpenGLPFADepthSize, (NSOpenGLPixelFormatAttribute)32,
      NSOpenGLPFASampleBuffers, (NSOpenGLPixelFormatAttribute)1,
      NSOpenGLPFASamples, (NSOpenGLPixelFormatAttribute)8,
      NSOpenGLPFANoRecovery,
      (NSOpenGLPixelFormatAttribute)nil
   };
   
   // Create the pixel-format object.
   NSOpenGLContext* myContext = nil;
   NSOpenGLPixelFormat* pixFmt = [[NSOpenGLPixelFormat alloc]
                                     initWithAttributes:attrs];
   
   // If the pixel format is valid, create the OpenGL context.
   if (pixFmt != nil)
   {
      myContext = [[NSOpenGLContext alloc] initWithFormat:pixFmt
                                             shareContext:nil];
   }
   else 
   {
      NSAssert(false, @"Creation of the pixel format failed");
   }
   
   [pixFmt release];  
   return myContext;
}  

/**
 * Set tracking rectangle for mouse tracking
 */
-(void)setTrackingRectangle
{
   if (trackingRectangle)
      [self removeTrackingRect:trackingRectangle];
   
   trackingRectangle = [self addTrackingRect:[self visibleRect] owner:self userData:nil assumeInside:YES];
}

/**
 * Creates drawing code abstraction layer. <b>Note that this method doesn't have anything to do with Cocoa drawers.</b>
 *
 * @return Created drawing code helper.
 */
- (AbstractDrawingCode *)createDrawer
{
   if (!drawer)
   {
      drawer = new OpenGLDrawingCode();
      mouseAdapter = new MouseAdapter();
      mouseAdapter->setDrawer(drawer);
   }
   
   return drawer;
}

/**
 * Internal initialization
 */
- (void)prepare
{
   trackingRectangle = nil;
   contextInitalized = NO;
   if (!contextInitalized)
   {
      [self setOpenGLContext:[self getMyContext]];
      contextInitalized = YES;
   }
   
   NSOpenGLContext *glContext = [self openGLContext];
   [glContext makeCurrentContext];
   
	{
		/* Sync to VBL to avoid tearing. */
		GLint VBL = 1;
		[[self openGLContext] setValues:&VBL forParameter:NSOpenGLCPSwapInterval];
	}
   
   // Add tracking rectangle for mouse move
   [self setTrackingRectangle];
   
   drawer = [self createDrawer];
   drawer->initializeDrawingMode();
}

/**
 * Constructor
 *
 * @param frame Rectangle of the view
 * @param pixFmt Pixel format to use
 */
- (id)initWithFrame:(NSRect)frame
        pixelFormat:(NSOpenGLPixelFormat *)pixFmt
{
   self = [super initWithFrame:frame pixelFormat:pixFmt];
   contextInitalized = NO;
   [self prepare];
   return self;
}

/**
 * Constructor. Called when we are initilized from file
 *
 * @param coder Coder to use for initialization
 */
- (id)initWithCoder:(NSCoder *)coder
{	
	self = [super initWithCoder:coder];
   contextInitalized = NO;
   [self prepare];
   return self;
}

/**
 * To stop animation when window is closing
 */
- (BOOL)windowShouldClose:(id)sender
{
   animationRunning = NO;
   return YES;
}

/**
 * Invoked on windows close
 */
- (void)cleanForClose
{
   // In Cocoa, you need to invalidate timer from the same thread that created it
   [openGLAnimationTimer invalidate];
   [openGLAnimationTimer release];
   
   // Delete OpenGL context   
   delete drawer;
   drawer = NULL;
}

/**
 * Called by GC
 */
- (void)finalize
{
   [self cleanForClose];
   [super finalize];
}

/**
 * Called by manual GC
 */
- (void) dealloc
{
   [self cleanForClose];
   [super dealloc];
}


/**
 * Callback for mouse entering the tracking rectangle
 *
 * @param theEvent NSEvent generated by the system
 */
- (void)mouseEntered:(NSEvent *)theEvent
{
}

/**
 * Callback for mouse exiting the tracking rectangle
 *
 * @param theEvent NSEvent generated by the system
 */
- (void)mouseExited:(NSEvent *)theEvent
{
}

/**
 * Callback for window resize
 */
- (void)reshape
{
   [self setTrackingRectangle];
   
   NSRect rect = [self bounds];
      
   // Resize data from drawer
   drawer->setBounds(rect.size.width, rect.size.height);
   drawer->setAspectRatio(rect.size.width/(double)rect.size.height);

   [self setNeedsDisplay:YES];
}

/**
 * Recalc value of the FOV from slider. Used so that we could invert zoom slider, with the higher zoom being up
 *
 * @param sender Caller that is holding FOV information
 */
- (double)recalcFOVFromSlider:(id)sender
{
   double max = [sender maxValue];
   double min = [sender minValue];
   double fov = [sender floatValue];
   return max - fov + min;
}

/**
 * Recalc value of the FOV slider based on FOV of the model. Used so that we could invert zoom slider, with the higher zoom being up
 *
 * @param value Caller that is holding FOV information
 */
- (double)recalcFOVToSlider:(double)value
{
   double max = [fovSlider maxValue];
   double min = [fovSlider minValue];
   return max - value + min;
}

/**
 * Setup animation in openGLAnimationTimer variable
 */
- (void)setupAnimation
{
   // This will set repeated animation timer to triger notification
	SEL selector;
	NSMethodSignature *signature;
	NSInvocation *invocation;
   
	// animationCallback is my animation callback method
	selector = @selector(animationCallback);
	signature = [HoloDeckView instanceMethodSignatureForSelector:selector];
	invocation = [NSInvocation invocationWithMethodSignature:signature] ;
	[invocation setSelector:selector];
	[invocation setTarget:self];
	
	openGLAnimationTimer = [NSTimer scheduledTimerWithTimeInterval:1.0/FRAMES_PER_SECOND
                                                       invocation:invocation
                                                          repeats:YES];
	[openGLAnimationTimer retain];
	
	// If single threaded, Cocoa blocks timers when popup box or move a slider or printing is invoked.
	// We will allow that blockage
	[[NSRunLoop currentRunLoop] addTimer:openGLAnimationTimer forMode:NSDefaultRunLoopMode];
   
	// Run animation even if popup box or slider are moved. 
	[[NSRunLoop currentRunLoop] addTimer:openGLAnimationTimer forMode:NSEventTrackingRunLoopMode];
   
	// Run loop for dialogs and menus
	[[NSRunLoop currentRunLoop] addTimer:openGLAnimationTimer forMode:NSModalPanelRunLoopMode];
}

/**
 * Awake from NIB. Will set limits of control movement based on limits in other UI elements
 */
- (void)awakeFromNib
{
   drawer = [self createDrawer];
   drawer->setFOV([self recalcFOVFromSlider:fovSlider]);
   drawer->setRotationAngles([xSlider floatValue], [ySlider floatValue], [zSlider floatValue]);
   mouseAdapter->setMinFOV([fovSlider minValue]);
   mouseAdapter->setMaxFOV([fovSlider maxValue]);
   animationRunning = NO;

   openGLAnimationTimer = nil;   
   [self setupAnimation];
}

// Public method
- (IBAction)fovSliderChanged:(id)sender
{
   drawer->setFOV([self recalcFOVFromSlider:sender]);
   [self setNeedsDisplay:YES];
}

- (IBAction)xSliderChanged:(id)sender
{
   drawer->setRotationAngles([sender floatValue], 
                             drawer->getRotationAngleY(),
                             drawer->getRotationAngleZ());
                             
   [self setNeedsDisplay:YES];
}

- (IBAction)ySliderChanged:(id)sender
{
   drawer->setRotationAngles(drawer->getRotationAngleX(),
                             [sender floatValue], 
                             drawer->getRotationAngleZ());

   [self setNeedsDisplay:YES];
}

- (IBAction)zSliderChanged:(id)sender
{
   drawer->setRotationAngles(drawer->getRotationAngleX(),
                             drawer->getRotationAngleY(),
                             [sender floatValue]);
   
   [self setNeedsDisplay:YES];
}

/**
 * Stop animation
 */
- (void)stopAnimation
{
   // No need to stop the timer, just change variable
   @synchronized (self) 
   {
      animationRunning = NO;
   }

   [playPauseButton setState:NO];
}

/**
 * Start animation
 */
- (void)startAnimation
{
   // No need to stop the timer, just change variable
   @synchronized (self) 
   {
      animationRunning = YES;
   }

   [playPauseButton setState:YES];
}

- (IBAction)toggleAnimation:(id)sender
{
   @synchronized (self)
   {
      if (animationRunning)
         [self stopAnimation];
      else
         [self startAnimation];
      
   }

   // No need to refresh, this is not immediatelly changing picture   
}

- (IBAction)notifyModelChanged:(id)sender
{
   InterpolatedModel *m = dynamic_cast<InterpolatedModel *>([sender model]);
	[timeSliceSlider setFloatValue:m->getTimeSlice()];

   @synchronized(self)
   {
      if (animationRunning)
         [self stopAnimation];
   }
   
   [self setNeedsDisplay:YES];
}

/**
 * Helper used to update drag information during mouse move rotation
 */
- (void)rotateModelForDrag
{
   @synchronized(self)
   {
      mouseAdapter->setMouseFOVRatio([model mouseZoomSpeed]);
      mouseAdapter->setMouseMoveRatio([model mouseRotationSpeed]);
   }
   
   // Calculate distance we were dragging
   float xDistance = mouseDragCurrent.x - mouseDragStart.x;
   float yDistance = mouseDragCurrent.y - mouseDragStart.y;
   
   // And send this distance to the controller adapter to rotate model
   mouseAdapter->controlForMouseAt(xDistance, yDistance, /* lmb */true, /* rmb */false);
}

/**
 * Callback invoked when mouse button is up
 *
 * @param theEvent Generated NSEvent
 */
- (void)leftMouseUp:(NSEvent *)theEvent
{
	[self rotateModelForDrag];
   [self setNeedsDisplay:YES];
}

/**
 * Callback invoked when mouse is dragged
 *
 * @param theEvent Generated NSEvent
 */
- (void)mouseDragged:(NSEvent *)theEvent
{
   // Only rotate on left mouse button
   if ([theEvent buttonNumber] == 0) 
   {
      NSPoint point = [theEvent locationInWindow];
      mouseDragCurrent = [self convertPoint:point fromView:nil];

      [self rotateModelForDrag];
      [self setNeedsDisplay:YES];
      
      // And change initial point to be equal to the current point, as we want next mouse drag event to be from this point as opposed to initial
      mouseDragStart = mouseDragCurrent;
   }
}

/**
 * Callback invoked when left mouse button is pressed (but not released). NOTE: This is not standard Cocoa callback, but callback 
 * invoked from standard Cocoa callback mouseDown
 *
 * @param theEvent Generated NSEvent
 */
- (void)leftMouseButtonDown:(NSEvent *)theEvent
{
   NSPoint point = [theEvent locationInWindow];
   mouseDragStart = [self convertPoint:point fromView:nil];     
}

/**
 * Callback invoked when scrollwheel is moved
 *
 * @param deltaX X distance length
 * @param deltaY Y distance length
 * @param deltaZ Z distance length
 */
- (void)scrollWheel:(double)deltaX
             deltaY:(double)deltaY
             deltaZ:(double)deltaZ
{
   mouseAdapter->controlForMouseScrollChange(deltaX, deltaY, deltaZ);
   [self setNeedsDisplay:YES];
}

/**
 * Callback invoked when scrollwheel is moved
 *
 * @param theEvent Generated NSEvent
 */
- (void)scrollWheel:(NSEvent *)theEvent
{
   [self scrollWheel:[theEvent deltaX]deltaY:[theEvent deltaY]deltaZ:[theEvent deltaZ]];
}

/**
 * Emulate multiple buttons on 1 button mac mouse
 *
 * @param theEvent Event Used
 */
- (void) mouseDown:(NSEvent*)theEvent
{
	if ([theEvent modifierFlags] & NSAlternateKeyMask)
   {
		[self scrollWheel:EMULATE_MOUSE_WHEEL deltaY:EMULATE_MOUSE_WHEEL deltaZ:EMULATE_MOUSE_WHEEL];
   }
	else if ([theEvent modifierFlags] & NSControlKeyMask)
   {
		[self scrollWheel:-EMULATE_MOUSE_WHEEL deltaY:-EMULATE_MOUSE_WHEEL deltaZ:-EMULATE_MOUSE_WHEEL];
   }
	else
		[self leftMouseButtonDown:theEvent];
}

/**
 * Callback called when this window needs to redisplay itself
 *
 * @param rect Rectangle that needs to be redisplayed. We always redisplay whole window
 */
- (void)drawRect:(NSRect)rect
{
   drawer->draw([model model]);
   
   // And update UI
   [xSlider setFloatValue:drawer->getRotationAngleX()];
   [ySlider setFloatValue:drawer->getRotationAngleY()];
   [zSlider setFloatValue:drawer->getRotationAngleZ()];
   [fovSlider setFloatValue:[self recalcFOVToSlider:drawer->getFOV()]];
}

/**
 * This method would be invoked once every time our animation callback triggers
 */
- (void)animationCallback
{
   // New value of the timeslice
   double newTimeslice;
   
   // Make sure that no paramters are changed while I am setting frame values
   @synchronized(self)
   {
      if (!animationRunning)
         return;
      
      InterpolatedModel *m = dynamic_cast<InterpolatedModel *>([model model]);
      if (!m)
         return;
      
      newTimeslice = m->getTimeSlice() + [model interframeDistance];
      
      if ([model loopAnimation])
      {
         // Loop at the same place from the beginning as would be if this was circular tape. Helps with avoiding discontinuity at the moment of jump
         newTimeslice = newTimeslice < InterpolatedModel::MAX_TIME_SLICE ? newTimeslice : (newTimeslice - InterpolatedModel::MAX_TIME_SLICE) + InterpolatedModel::MIN_TIME_SLICE;
      }
		else
      {
	      newTimeslice = newTimeslice <= InterpolatedModel::MAX_TIME_SLICE ? newTimeslice : InterpolatedModel::MAX_TIME_SLICE;
      }
      
      m->setTimeSlice(newTimeslice);
   }

   [timeSliceSlider setFloatValue:newTimeslice];
   [self setNeedsDisplay:YES];
}

@end
