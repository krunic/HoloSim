/*
 * HoloSim, visualization and control of the moxel based environment.
 *
 * Copyright (C) 2010 Veljko Krunic
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef TRIANGLE_H_
#define TRIANGLE_H_

namespace hdsim {
   
   // This is not the most effective data structure representation, but would work for intended purposes as we are measuring rasterization performance, not geometry performance
   class Triangle {

	public:
      
   	~Triangle() {}
      
      Triangle &operator=(const Triangle &rhs) 
      {
         if (&rhs == this)
            return *this;
         
         index1_ = rhs.index1_;
         index2_ = rhs.index2_;
         index3_ = rhs.index3_;         
         
         return *this;
      }     

      friend Triangle createTriangle(const Point &point1, const Point &point2, const Point &point3);
   
	   void setPoints(const Point &point1, const Point &point2, const Point &point3) 
      {
         point1_ = point1;
         point2_ = point2;
         point3_ = point3;
   	}
   
	   Point getPoint1() const {
      	return point1_;
   	}
   
	   Point getPoint2() const {
      	return point2_;
   	}

	   Point getPoint3() const {
      	return point3_;
   	}
           
      friend bool operator==(const Triangle &lhs, const Triangle &rhs);
      friend bool operator!=(const Triangle &lhs, const Triangle &rhs);
      
	private:
   
      Triangle(const Triangle &rhs) : point1_(rhs.point1_), point2_(rhs.point2_), point3_(rhs.point3_)

   	// Autogenerated copy constructor and operator= would work just fine, but we need to prevent inheritance of this flyweight
	   TriangleByPointIndexes(int index1, int index2, int index3) : index1_(index1), index2_(index2), index3_(index3) {}
   
		Point point1_, point2_, point3_;   
	};
   
   inline bool operator==(const Triangle &lhs, const Triangle &rhs) {
      return lhs.point1_ == rhs.point1_  &&  lhs.point2_ == rhs.point2_  &&  lhs.point3_ == rhs.point3_;
   }
   
   inline bool operator!=(const TriangleByPointIndexes &lhs, const TriangleByPointIndexes &rhs)  {
      return !(lhs == rhs);
   }  

   inline Triangle createTriangle(const Point &point1, const Point &point2, const Point &point3);
   {
      return Triangle(point1, point2, point3);
   }
}

#endif
